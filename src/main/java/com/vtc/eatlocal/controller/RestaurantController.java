package com.vtc.eatlocal.controller;

import com.vtc.eatlocal.entity.*;
import com.vtc.eatlocal.model.*;
import com.vtc.eatlocal.repository.*;
import com.vtc.eatlocal.service.restaurant.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Optional;

@Controller
@CrossOrigin(origins = {"http://localhost:3000", "http://192.168.1.7:3000", "http://192.168.1.7:8080", "http://eat-local.us-east-1.elasticbeanstalk.com"})
@RequestMapping(path="/restaurant-path") // This means URL's start with /demo (after Application path)
public class RestaurantController {

    public static final String DELIMITTER_COMMA = ",";

    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private RestaurantRepository restaurantRepository;

    @Autowired
    private RestaurantCredentialsRepository restaurantCredentialsRepository;

    @Autowired
    private OpenChallengeRepository openChallengeRepository;

    @Autowired
    private LiveChallengeRepository liveChallengeRepository;

    @Autowired
    private RestaurantJoinChallengeService restaurantJoinChallengeService;

    @Autowired
    private RestaurantExitChallengeService restaurantExitChallengeService;

    @Autowired
    private RestaurantChallengeService restaurantChallengeService;

    @Autowired
    private OrderValidationService orderValidationService;

    @Autowired
    private RedeemRewardService redeemRewardService;

    @Autowired
    private OrderReportsService orderReportsService;

    @Autowired
    private RewardReportService rewardReportService;

    @Autowired
    private RestaurantAccountService restaurantAccountService;

    @Autowired
    private OpenChallengeService openChallengeService;

    @PostMapping(path="/save-data") // Map ONLY POST Requests
    public @ResponseBody
    RestaurantCreateAccountResponse createAccount (@RequestBody Restaurant restaurant ) {

        RestaurantCreateAccountResponse response = new RestaurantCreateAccountResponse();

        // return error if email already exists
        String email = restaurant.getEmail();
        boolean emailExists = restaurantCredentialsRepository.findById(email).isPresent();
        if(emailExists) {
            response.setCreateAccountStatus(false);
            response.setRestaurantCreateAccountMessage("Email already exists");
        } else {
            // Save user data
            response.setCreateAccountStatus(true);
            restaurant  = restaurantRepository.save(restaurant);
            response.setRestaurantId(restaurant.getId());

            RestaurantCredentials restaurantCredentials = new RestaurantCredentials();
            restaurantCredentials.setUsername(restaurant.getEmail());
            restaurantCredentials.setPassword(restaurant.getPassword());

            restaurantCredentialsRepository.save(restaurantCredentials);
        }


        return response;
    }

    @PostMapping(path="/signin") // Map ONLY POST Requests
    public @ResponseBody
    RestaurantLoginResponse validateCredentials (@RequestBody RestaurantCredentials restaurantCredentialsEntered) {

        String username = restaurantCredentialsEntered.getUsername();
        Optional<RestaurantCredentials> credentials_db = restaurantCredentialsRepository.findById(username);

        RestaurantLoginResponse response = new RestaurantLoginResponse();

        if(credentials_db.isPresent()) {
            String passwordFromDB = credentials_db.get().getPassword();
            String passwordEntered = restaurantCredentialsEntered.getPassword();

            if(passwordEntered.equals(passwordFromDB)) {
                List<Restaurant> all = restaurantRepository.findAll();
                for(Restaurant restaurant : all) {
                    if(restaurant.getEmail().equals(restaurantCredentialsEntered.getUsername())) {
                        response.setRestaurantId(restaurant.getId());
                        response.setRestaurantName(restaurant.getRestaurantName());
                    }
                }
                response.setLoginStatus(true);
            } else {
                response.setLoginStatus(false);
                response.setMessage("Incorrect Password");
            }

        } else {
            response.setLoginStatus(false);
            response.setMessage("Account not found");
        }

        return response;
    }

    @GetMapping(path="/all")
    public @ResponseBody Iterable<Restaurant> getAllUsers() {
        // This returns a JSON or XML with the users
        return restaurantRepository.findAll();
    }


    @PostMapping(path="/propose-challenge")
    public @ResponseBody
    ProposeChallengeResponse proposeChallenge (@RequestBody OpenChallenge openChallenge) {

        ProposeChallengeResponse challengeResponse = new ProposeChallengeResponse();

        if(openChallengeService.doesOpenChallengeExist(openChallenge.getChallengeTitle())) {
            challengeResponse.setProposeChallengeStatus(false);
            challengeResponse.setProposeChallengeMessage("Challenge Already Exists!");
            return challengeResponse;
        }

       try {
           openChallenge.setVacancy(openChallenge.getMaximum());
           openChallengeRepository.save(openChallenge);
           challengeResponse.setProposeChallengeStatus(true);
           challengeResponse.setProposeChallengeMessage("Challenge created successfully!");
       }
       catch(Exception e) {
           challengeResponse.setProposeChallengeStatus(false);
           challengeResponse.setProposeChallengeMessage(e.getMessage());
        }

       return  challengeResponse;
    }

    @GetMapping(path="/all-proposed-challenges")
    public @ResponseBody Iterable<OpenChallenge> getAllProposedChallenges() {
        // This returns a JSON or XML with the users
        return openChallengeRepository.findAll();
    }

    @PostMapping(path="/get-enrolled-challenges")
    public @ResponseBody Iterable<String> getEnrolledChallengeIds(@RequestBody JoinChallengeInfo joinChallengeInfo) {
        return restaurantChallengeService.getEnrolledChallengeIds(joinChallengeInfo);
    }

    @PostMapping(path="/get-enrolled-challenge-names")
    public @ResponseBody Iterable<String> getEnrolledChallengeNames(@RequestBody JoinChallengeInfo joinChallengeInfo) {
       return restaurantChallengeService.getEnrolledChallengeNames(joinChallengeInfo);
    }


    @PostMapping(path="/join-challenge")
    public @ResponseBody
    Boolean joinChallenge (@RequestBody JoinChallengeInfo joinChallengeInfo) {
        return restaurantJoinChallengeService.joinChallenge(joinChallengeInfo);
    }

    @PostMapping(path="/exit-challenge")
    public @ResponseBody
    Boolean exitChallenge (@RequestBody JoinChallengeInfo joinChallengeInfo) {
        return restaurantExitChallengeService.exitChallenge(joinChallengeInfo);
    }

//    @PostMapping(path = "/get-all-restaurantIds-for-challenge")
//    public @ResponseBody
//    Iterable<String> getAllRestaurantIdsForChallenge(@RequestBody CustomerChallenegeAssociation cca) {
//        return restaurantChallengeService.getAllRestaurantsForChallenge(cca);
//    }

    @GetMapping(path = "/get-all-restaurants-for-challenge")
    public @ResponseBody
    Iterable<Restaurant> getAllRestaurantsForChallenge(@RequestParam int challengeId) {
        return restaurantChallengeService.getAllRestaurantsForChallenge(challengeId);
    }

    @GetMapping(path = "/get-all-restaurant-names-for-challenge")
    public @ResponseBody
    List<String> getAllRestaurantNamesForChallenge(@RequestParam int challengeId) {
        return restaurantChallengeService.getAllRestaurantNamesForChallenge(challengeId);
    }

    @GetMapping(path="/all-live-challenges")
    public @ResponseBody Iterable<LiveChallenge> getAllLiveChallenges() {
        // This returns a JSON or XML with the users
        return liveChallengeRepository.findAll();
    }

    @PostMapping(path="/validate-order")
    public @ResponseBody OrderValidationResponse validateOrder(@RequestBody OrderValidation orderValidation) {
        return orderValidationService.validateOrder(orderValidation);
    }

    @PostMapping(path="/validate-order-with-value-check")
    public @ResponseBody OrderValidationResponse validateOrderWithValueCheck(@RequestBody OrderValidation orderValidation) {
        return orderValidationService.validateOrderWithOrderValue(orderValidation);
    }

    @PostMapping(path="/redeem-reward")
    public @ResponseBody RedeemRewardResponse redeemReward(@RequestParam int customerId, @RequestParam String customerName,
                                              @RequestParam int challengeId, @RequestParam String challengeName,
                                              @RequestParam int restaurantId, @RequestParam String restaurantName) {
        return  redeemRewardService.redeemReward(customerId, customerName, challengeId, challengeName, restaurantId, restaurantName);
    }

    @GetMapping(path="/get-report")
    public @ResponseBody List<OrderValidation> getOrderReport(@RequestParam int restaurantId, @RequestParam String reportType) throws Exception {
        // This returns a JSON or XML with the users
        return orderReportsService.generateReport(restaurantId, reportType);
    }

    @GetMapping(path="/get-reward-report")
    public @ResponseBody List<RewardHistory> getRewardReport(@RequestParam int restaurantId, @RequestParam String reportType) throws Exception {
        // This returns a JSON or XML with the users
        return rewardReportService.generateRewardReport(restaurantId, reportType);
    }

    @PostMapping(path="/reset-restaurant-password")
    public @ResponseBody RestaurantLoginResponse resetRestaurantPassword(@RequestBody RestaurantCredentials restaurantCredentials) {
        return  restaurantAccountService.resetRestaurantPassword(restaurantCredentials);
    }

    @PostMapping(path="/send-password-reset-email")
    public @ResponseBody RestaurantLoginResponse sendPasswordResetEmail(@RequestBody Restaurant restaurant) {
        return  restaurantAccountService.sendPasswordResetEmail(restaurant);
    }

}